return(res)
}
#fc <- get_args(fc=fc, vars=mget(ls()))
ora_splitted <- split(fc@ora, fc@ora$Module)
module_cols <- fc@mod_colors
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module),
...)
})
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module))
n = 10
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module))
})
pv_cut=0.05
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module))
})
library(ggplot2)
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module))
})
modules <- names(res)
modules <- modules[names(fc@module_list)]
fc@barplot_ora <- res[modules]
save_plots(fc)
save_plots(fc, T)
save_plots(fc, force = T)
save_plots(name = "ble', fc, force = T)
save_plots(name = "ble", fc, force = T)
fc@barplot_ora <- res[modules]
save_plots(name = "ble", fc, force = T)
fc@barplot_ora[1]
res[1]
res[2]
fc@barplot_ora <- res
save_plots(name = "ble", fc, force = T)
document()
library(TENxPBMCData)
installed.packages(TENxPBMCData)
installed.packages(TENxPBMCData)
install.packages(TENxPBMCData)
install.packages('TENxPBMCData')
BiocManager::install('TENxPBMCData')
# normalize data
sce <- scater::normalize(sce)
BiocManager::install('TENxPBMCData', 'scater')
BiocManager::install(c('TENxPBMCData', 'scater'))
BiocManager::install('scran')
BiocManager::install('scran')
BiocManager::install('scran')
library(scran)
quote(rJava, boot, class, codetools, foreign, KernSmooth, lattice,
Matrix, mgcv, nlme, nnet, spatial, survival)
as.character(expression(rJava, boot, class, codetools, foreign, KernSmooth, lattice,
Matrix, mgcv, nlme, nnet, spatial, survival))
pkgs <- as.character(expression(rJava, boot, class, codetools, foreign, KernSmooth, lattice,
Matrix, mgcv, nlme, nnet, spatial, survival))
remove.packages(pkgs)
install.packages(pkgs)
install.packages(pkgs)
install.packages(pkgs)
BiocManager::install('scater')
BiocManager::install('scran')
sce <- TENxPBMCData('pbmc3k')
library(TENxPBMCData)
sce <- TENxPBMCData('pbmc3k')
sce <- TENxPBMCData('pbmc3k')
## reassign rownames
rownames(sce) <- rowData(sce)[, "Symbol_TENx"]
## counts dupes from top to bottom to make a logical vector and remove-it
dupes <- duplicated(rownames(sce))
sce <- sce[!dupes, ]
# normalize data
sce <- scater::normalize(sce)
#get variable genes and run PCA
library(scran)
fit <- trendVar(sce, use.spikes = FALSE)
fit <- trendVar(sce, use.spikes = FALSE)
dec <- decomposeVar(sce, fit)
dec <- dec[order(dec$bio, decreasing = TRUE), ] # order by bio var
hvg_genes <- rownames(dec)[dec$bio > 0]
metadata(sce)$hvg_genes <- hvg_genes
sce <- runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
sce <- scater::runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
sce <- scater::runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
# get clusters
set.seed(1234) # to make results reproducible
snng <- buildSNNGraph(sce, k = 50, d = 20)
snng_clusters <- igraph::cluster_louvain(snng)
colData(sce)$clusters <- as.factor(snng_clusters$membership)
colData(sce)$clusters
hvg_genes[1:250]
sce
exprs <- assay(sce, 'logcounts')
target <- colData(sce)$clusters
library(fcoex)
fc <- new_fcoex(exprs, target)
exprs <- as.data.frame(assay(sce, 'logcounts'))
fc <- new_fcoex(exprs, target)
fc <- discretize(fc)
fc <- new_fcoex(data.frame(exprs),target)
fc <- discretize(fc, number_of_bins = 8)
fc <- discretize(fc, number_of_bins = 8)
devtools::document()
devtools::install()
fc <- discretize(fc, number_of_bins = 8)
discretized_expression <-FCBF::discretize_exprs(expression_table = exprs,
number_of_bins = 8,
method = "varying_width",
alpha = 1,
centers = 3,
min_max_cutoff = 0.25,
show_pb = TRUE)
discretized_expression <-FCBF::discretize_exprs(expression_table = exprs,
number_of_bins = 8)
devtools::install_github('lubianat/FCBF')
#BiocManager::install(c('TENxPBMCData', 'scater', 'scran'))
library(TENxPBMCData)
sce <- TENxPBMCData('pbmc3k')
## reassign rownames
rownames(sce) <- rowData(sce)[, "Symbol_TENx"]
## counts dupes from top to bottom to make a logical vector and remove-it
dupes <- duplicated(rownames(sce))
sce <- sce[!dupes, ]
# normalize data
sce <- scater::normalize(sce)
#get variable genes and run PCA
library(scran)
fit <- trendVar(sce, use.spikes = FALSE)
dec <- decomposeVar(sce, fit)
dec <- dec[order(dec$bio, decreasing = TRUE), ] # order by bio var
hvg_genes <- rownames(dec)[dec$bio > 0]
metadata(sce)$hvg_genes <- hvg_genes
sce <- scater::runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
# get clusters
set.seed(1234) # to make results reproducible
snng <- buildSNNGraph(sce, k = 50, d = 20)
snng_clusters <- igraph::cluster_louvain(snng)
colData(sce)$clusters <- as.factor(snng_clusters$membership)
target <- colData(sce)$clusters
exprs <- as.data.frame(assay(sce, 'logcounts'))
library(fcoex)
fc <- new_fcoex(data.frame(exprs),target)
fc <- discretize(fc, number_of_bins = 8)
sce.pbmc
data(sce.pbmc)
data("sce.pbmc"")
data("sce.pbmc")
data("sce.pbmc")
snng <- buildSNNGraph(sce, k = 50, d = 20, use.dimred = "PCA")
snng <- buildSNNGraph(sce, k = 50, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
snng_clusters
snng_clusters$membership
table(snng_clusters$membership)
snng <- buildSNNGraph(sce, k = 5, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
snng <- buildSNNGraph(sce, k = 5, use.dimred = "PCA")
table(snng_clusters$membership)
snng <- buildSNNGraph(sce, k = 15, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
snng_clusters <- igraph::cluster_louvain(snng)
snng_clusters$membership
table(snng_clusters$membership)
nrow(sce)
sce <- sce[hvg_genes,sample(ncol(sce),600)]
## counts dupes from top to bottom to make a logical vector and remove-it
dupes <- duplicated(rownames(sce))
sce <- sce[!dupes, ]
# normalize data
sce <- scater::normalize(sce)
#get variable genes and run PCA
library(scran)
fit <- trendVar(sce, use.spikes = FALSE)
dec <- decomposeVar(sce, fit)
dec <- dec[order(dec$bio, decreasing = TRUE), ] # order by bio var
hvg_genes <- rownames(dec)[dec$bio > 0]
metadata(sce)$hvg_genes <- hvg_genes
sce <- scater::runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
# get clusters
set.seed(1234) # to make results reproducible
snng <- buildSNNGraph(sce, k = 6, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
colData(sce)$clusters <- as.factor(snng_clusters$membership)
#visualize the data
plotReducedDim(sce, use_dimred="PCA", colour_by="clusters")
#visualize the data
library(scater)
sce <- runUMAP(sce, use_dimred="PCA")
plotReducedDim(sce, use_dimred="UMAP", colour_by="clusters")
# subset for brevity
set.seed(3)
sce <- sce[hvg_genes,sample(ncol(sce),600)]
## counts dupes from top to bottom to make a logical vector and remove-it
dupes <- duplicated(rownames(sce))
sce <- sce[!dupes, ]
# normalize data
sce <- scater::normalize(sce)
#get variable genes and run PCA
library(scran)
fit <- trendVar(sce, use.spikes = FALSE)
fit <- trendVar(sce, use.spikes = FALSE)
dec <- decomposeVar(sce, fit)
dec <- decomposeVar(sce, fit)
dec <- dec[order(dec$bio, decreasing = TRUE), ] # order by bio var
dec <- dec[order(dec$bio, decreasing = TRUE), ] # order by bio var
hvg_genes <- rownames(dec)[dec$bio > 0]
hvg_genes <- rownames(dec)[dec$bio > 0]
metadata(sce)$hvg_genes <- hvg_genes
sce <- scater::runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
snng <- buildSNNGraph(sce, k = 5, use.dimred = "PCA")
snng <- buildSNNGraph(sce, k = 6, use.dimred = "PCA")
snng <- buildSNNGraph(sce, k = 7, use.dimred = "PCA")
snng <- buildSNNGraph(sce, k = 8, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
snng <- buildSNNGraph(sce, k = 10, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
snng <- buildSNNGraph(sce, k = 5, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
colData(sce)$clusters <- as.factor(snng_clusters$membership)
#visualize the data
library(scater)
sce <- runUMAP(sce, use_dimred="PCA")
plotReducedDim(sce, use_dimred="UMAP", colour_by="clusters")
target <- colData(sce)$clusters
exprs <- as.data.frame(assay(sce, 'logcounts'))
library(fcoex)
fc <- new_fcoex(data.frame(exprs),target)
fc <- discretize(fc, number_of_bins = 8)
fc <- find_cbf_modules(fc,n_genes = 200, verbose = FALSE)
fc <- find_cbf_modules(fc,n_genes = 200, verbose = FALSE, is_parallel = TRUE)
fc <- plot_interactions(fc)
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_in <- read_gmt(gmt_fname)
fc <- mod_ora(fc, gmt_in)
fc <- plot_ora(fc)
save_plots(name = "fcoex_vignette", fc, force = TRUE)
fc <- recluster(fc)
sce@colData <- cbind(colData(sce), mod_FCER1G = fc@mod_idents$FCER1G)
sce@colData <- cbind(colData(sce), mod_CD3D = fc@mod_idents$CD3D)
# Let's see the original clusters
plotReducedDim(sce, use_dimred="UMAP", colour_by="clusters")
# And let's see the population represented in the modules CD3D and FCER1G.
# Notably, the patterns are largely influenced by the patterns of header genes
plotReducedDim(sce, use_dimred="UMAP", colour_by="mod_FCER1G")
plotReducedDim(sce, use_dimred="UMAP", colour_by="FCER1G")
plotReducedDim(sce, use_dimred="UMAP", colour_by="mod_CD3D")
plotReducedDim(sce, use_dimred="UMAP", colour_by="CD3D")
mini_pbmc3k <- sce
save(mini_pbmc3k, "data/mini_pbmc3k.rda")
save("data/mini_pbmc3k.rda", mini_pbmc3k)
save( file =  "data/mini_pbmc3k.rda", list =  "mini_pbmc3k"")
save( file =  "data/mini_pbmc3k.rda", list =  "mini_pbmc3k")
save( file =  "data/mini_pbmc3k.rda", list =  "mini_pbmc3k")
save( file =  "data/mini_pbmc3k.rda", list =  "mini_pbmc3k")
document()
devtools::document()
devtools::document()
data("mini_pbmc3k")
mini_pbmc3k
target <- colData(mini_pbmc3k)$clusters
exprs <- as.data.frame(assay(sce, 'logcounts'))
library(fcoex)
fc <- new_fcoex(data.frame(exprs),target)
fc <- discretize(fc, number_of_bins = 8)
fc <- find_cbf_modules(fc,n_genes = 200, verbose = FALSE, is_parallel = TRUE)
target <- colData(mini_pbmc3k)$clusters
exprs <- as.data.frame(assay(sce, 'logcounts'))
library(fcoex)
fc <- new_fcoex(data.frame(exprs),target)
fc <- discretize(fc, number_of_bins = 8)
fc <- find_cbf_modules(fc,n_genes = 200, verbose = FALSE, is_parallel = TRUE)
fc <- plot_interactions(fc)
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_in <- read_gmt(gmt_fname)
gmt_in <- read_gmt(gmt_fname)
fc <- mod_ora(fc, gmt_in)
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_in <- read_gmt(gmt_fname)
gmt_in <- read_gmt(gmt_fname)
gmt_in <- read_gmt(gmt_fname)
target <- colData(mini_pbmc3k)$clusters
exprs <- as.data.frame(assay(sce, 'logcounts'))
library(fcoex)
fc <- new_fcoex(data.frame(exprs),target)
fc <- discretize(fc, number_of_bins = 8)
fc <- find_cbf_modules(fc,n_genes = 200, verbose = FALSE, is_parallel = TRUE)
fc <- plot_interactions(fc)
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_in <- read_gmt(gmt_fname)
read_gmt <- function(fname) {
res <- list(genes = list(), desc = list())
gmt <- file(fname)
gmt_lines <- readLines(gmt)
close(gmt)
gmt_list <-
lapply(gmt_lines, function(x)
unlist(strsplit(x, split = "\t")))
gmt_names <- vapply(gmt_list, '[', character(1))
gmt_desc <- lapply(gmt_list, '[', 2)
gmt_genes <- lapply(gmt_list, function(x) {
x[3:length(x)]
})
names(gmt_desc) <- names(gmt_genes) <- gmt_names
res <- do.call(rbind, lapply(names(gmt_genes),
function(n)
cbind.data.frame(
term = n,
gene = gmt_genes[[n]],
stringsAsFactors = FALSE
)))
res$term <- as.factor(res$term)
return(res)
}
gmt_in <- read_gmt(gmt_fname)
read_gmt <- function(fname) {
res <- list(genes = list(), desc = list())
gmt <- file(fname)
gmt_lines <- readLines(gmt)
close(gmt)
gmt_list <-
lapply(gmt_lines, function(x)
unlist(strsplit(x, split = "\t")))
gmt_names <- sapply(gmt_list, '[',1)
gmt_desc <- lapply(gmt_list, '[', 2)
gmt_genes <- lapply(gmt_list, function(x) {
x[3:length(x)]
})
names(gmt_desc) <- names(gmt_genes) <- gmt_names
res <- do.call(rbind, lapply(names(gmt_genes),
function(n)
cbind.data.frame(
term = n,
gene = gmt_genes[[n]],
stringsAsFactors = FALSE
)))
res$term <- as.factor(res$term)
return(res)
}
fc <- plot_interactions(fc)
fc <- plot_interactions(fc)
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_in <- read_gmt(gmt_fname)
fc <- mod_ora(fc, gmt_in)
fc <- plot_ora(fc)
save_plots(name = "fcoex_vignette", fc, force = TRUE)
fc <- recluster(fc)
sce@colData <- cbind(colData(sce), mod_FCER1G = fc@mod_idents$FCER1G)
sce@colData <- cbind(colData(sce), mod_CD3D = fc@mod_idents$CD3D)
# Let's see the original clusters
plotReducedDim(sce, use_dimred="UMAP", colour_by="clusters")
# And let's see the population represented in the modules CD3D and FCER1G.
# Notably, the patterns are largely influenced by the patterns of header genes
plotReducedDim(sce, use_dimred="UMAP", colour_by="mod_FCER1G")
plotReducedDim(sce, use_dimred="UMAP", colour_by="FCER1G")
# And let's see the population represented in the modules CD3D and FCER1G.
# Notably, the patterns are largely influenced by the patterns of header genes
plotReducedDim(sce, use_dimred="UMAP", colour_by="mod_FCER1G")
plotReducedDim(sce, use_dimred="UMAP", colour_by="FCER1G")
plotReducedDim(sce, use_dimred="UMAP", colour_by="mod_CD3D")
plotReducedDim(sce, use_dimred="UMAP", colour_by="CD3D")
# And let's see the population represented in the modules CD3D and FCER1G.
# Notably, the patterns are largely influenced by the patterns of header genes
plotReducedDim(sce, use_dimred="UMAP", colour_by="mod_FCER1G")
plotReducedDim(sce, use_dimred="UMAP", colour_by="FCER1G")
plotReducedDim(sce, use_dimred="UMAP", colour_by="mod_CD3D")
plotReducedDim(sce, use_dimred="UMAP", colour_by="CD3D")
mini_pbmc3k <- sce
BiocCheck::BiocCheck()
document()
devtools::document()
BiocCheck::BiocCheck()
#' Create a fcoex object
#'
#' @param expression Normalized gene expression table from single-cells \code{data.frame}.
#' @param target Original target classes for the cells (\code{factor}).
#' @return Object of class \code{fcoex}
#' @examples
#' # Create new fcoex object
data("mini_pbmc3k")
data('targets')
head(mini_pbmc3k)
colData(mini_pbmc3k)
mini_pbmc3k@colData
colData(mini_pbmc3k)
mini_pbmc3k@colData$clusters
library(SingleCellExperiment)
targets <- colData(mini_pbmc3k)$clusters
targets <- colData(mini_pbmc3k, clusters)
targets <- colData(mini_pbmc3k)$clusters
exprs <- assay(mini_pbmc3k, "logcounts")
fc <- new_fcoex(exprs, targets)
exprs <- as.data.frame(assay(mini_pbmc3k, "logcounts"))
fc <- new_fcoex(exprs, targets)
fc <- discretize(fc)
fc <- find_cbf_modules(fc)
fc <- plot_interactions(fc)
devtools::document()
#' @param fc Object of class \code{fcoex}
#'
#' @return A vector with color names.
#' @examples
#' data("mini_pbmc3k")
#' targets <- colData(mini_pbmc3k)$clusters
#' exprs <- as.data.frame(assay(mini_pbmc3k, "logcounts"))
#' fc <- new_fcoex(exprs, targets)
#' fc <- discretize(fc)
#' fc <- find_cbf_modules(fc)
mod_colors(fc)
fc@mod_colors
#' between each variable and the class used for wrapped FCBF function. Defaults to 0.1.
#' @param is_parallel Uses package parallel to paralleliza calculations. Defaults to FALSE.
#' @param verbose Adds verbosity. Defaults to TRUE
#' @param n_genes Sets the number of genes to be selected in the first part of the algorithm.
#' If left unchanged, it defaults to NULL and the thresh parameter is used.
#' Caution: it overrides the thresh parameter altogether.
#' @examples
#' data("mini_pbmc3k")
#' targets <- colData(mini_pbmc3k)$clusters
#' exprs <- as.data.frame(assay(mini_pbmc3k, "logcounts"))
fc <- new_fcoex(exprs, targets)
fc <- discretize(fc)
fc <- find_cbf_modules(fc)
fc@mod_colors
mod_gene_num(fc)
fc <- find_cbf_modules(fc)
mod_gene_num(fc)
nrow(module_genes(fc)
)
library(fcoex)
mod_gene_num(fc)
module_genes(fc)
nrow(module_genes(fc))
length(module_genes(fc))
#' Get the number of genes in modules in a fcoex object
#'
#' @param fc Object of class \code{fcoex}
#' @param module Default is NULL. If a character string designating a module is
#' given, the number of genes in that module is returned instead.
#' @examples
#' data("mini_pbmc3k")
#' targets <- colData(mini_pbmc3k)$clusters
#' exprs <- as.data.frame(assay(mini_pbmc3k, "logcounts"))
#' fc <- new_fcoex(exprs, targets)
#' fc <- discretize(fc)
#' fc <- find_cbf_modules(fc)
#' mod_gene_num(fc)
#' @return The number of genes in module(s)
#'
#' @rdname mod_gene_num
#' @export
setGeneric('mod_gene_num', function(fc, module = NULL) {
standardGeneric('mod_gene_num')
})
#' @rdname mod_gene_num
setMethod('mod_gene_num', signature(fc = 'fcoex'),
function(fc, module = NULL) {
if (!is.null(module)) {
if (!(all(module %in% mod_names(fc)))) {
stop("Module '", module, "' not in fcoex object!")
}
}
if (!length(module_genes(fc)) > 0) {
stop("No modules in fcoex object!")
}
if (!is.null(module)) {
mod_genes <- fc@module_list[[module]]
}
return(mod_genes)
})
fc
save(fc, "data/fc.rda")
save(list = fc, file = "data/fc.rda")
save(list = 'fc', file = "data/fc.rda")
devtools::document()
data(fc)
rm(fc)
data(fc)
data(fc)
rm(fc)
data(fc)
devtools::document()
devtools::document()
BiocCheck::BiocCheck()
BiocCheck::BiocCheck()
BiocCheck::BiocCheck()
data("fc")
rm(fc)
data("fc")
