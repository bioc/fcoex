}
# get only those with an SU score above a threshold
SU_threshold <- FCBF_threshold
su_ic_vector_small <- su_ic_vector[su_ic_vector[1] > SU_threshold,]
SU_genes <- gsub('\\.', '-',su_ic_vector_small[,2])
fc@selected_genes <-SU_genes
exprs_small <- discretized_exprs[SU_genes ,]
# get and adjacency matrix for gene to gene correlation
su_i_j_matrix <- data.frame(genes =  SU_genes)
message('Calculating adjacency matrix')
pb_findclusters <- progress_bar$new(total = length(SU_genes),
format =   "[:bar] :percent eta: :eta")
# this can surely be improved for speed.
for (i in SU_genes) {
pb_findclusters$tick()
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
}
# Second Try
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
toc()
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
toc()
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
stopCluster(cl)
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
toc()
stopCluster(cl)
stopCluster(cl)
stopCluster(cl)
stopCluster(cl)
str(discretized_exprs)
#' @param n_genes Sets the number of genes to be selected in the first part of the algorithm.
#' If left unchanged, it defaults to NULL and the thresh parameter is used.
#' Caution: it overrides the thresh parameter altogether.
#' @return Returns a list with the CBF modules found or a adjacency matrix of the graph
#' @import dplyr
#' @import parallel
#' @import progress
#' @import FCBF
#' @exportSSS
#' @rdname find_cbf_modules
setGeneric("find_cbf_modules", function(fc, ...) {
standardGeneric("find_cbf_modules")
})
source('~/Documents/Projects/side/fcoex/R/fcoex.R', echo=TRUE)
devtools::document()
devtools::document()
library(devtools)
devtools::install(
)
devtools::install()
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
cl <- makeCluster(detectCores()-2)
get("get_correlates")
cl <- parallel::detectCores()-2
cl <- detectCores()-2
devtools::document()
install()
devtools::document()
install()
data(expr0)
data("sample_annot")
fc <- new_fcoex(expr0, as.factor(sample_annot$Class)0
fc <- new_fcoex(expr0, as.factor(sample_annot$Class))
fc <- discretize(fc)
discretized_exprs <- fc@discretized_expression
target <- fc@target
# get the SU scores for each gene
message('Getting SU scores')
su_ic_vector <- FCBF::get_su(discretized_exprs, target)
su_ic_vector$gene <- rownames(su_ic_vector)
colnames(su_ic_vector)[1] <- 'SU'
message('Running FCBF to find module headers')
fcbf_filtered <- FCBF::fcbf(discretized_exprs, target, n_genes, thresh = FCBF_threshold, verbose = verbose)
fcbf_filtered$gene <- rownames(fcbf_filtered)
# R does not like points. Subs for -.
FCBF_genes <- gsub('\\.', '-', fcbf_filtered$gene)
fcbf_filtered <- FCBF::fcbf(discretized_exprs, target, n_genes, thresh = FCBF_threshold, verbose = verbose)
fcbf_filtered <- FCBF::fcbf(discretized_exprs, target, n_genes, thresh = FCBF_threshold, verbose = T)
n_genes = 100
fcbf_filtered <- FCBF::fcbf(discretized_exprs, target, n_genes, thresh = FCBF_threshold, verbose = verbose)
verbose = T
fcbf_filtered <- FCBF::fcbf(discretized_exprs, target, n_genes, thresh = FCBF_threshold, verbose = verbose)
fcbf_filtered$gene <- rownames(fcbf_filtered)
# R does not like points. Subs for -.
FCBF_genes <- gsub('\\.', '-', fcbf_filtered$gene)
if (length(n_genes)){
FCBF_threshold <- su_ic_vector$SU[n_genes]
}
# get only those with an SU score above a threshold
SU_threshold <- FCBF_threshold
su_ic_vector_small <- su_ic_vector[su_ic_vector[1] > SU_threshold,]
SU_genes <- gsub('\\.', '-',su_ic_vector_small[,2])
fc@selected_genes <-SU_genes
exprs_small <- discretized_exprs[SU_genes ,]
# get and adjacency matrix for gene to gene correlation
su_i_j_matrix <- data.frame(genes =  SU_genes)
message('Calculating adjacency matrix')
if (!is_parallel){
pb_findclusters <- progress_bar$new(total = length(SU_genes),
format =   "[:bar] :percent eta: :eta")
# this can surely be improved for speed.
for (i in SU_genes) {
pb_findclusters$tick()
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
}
}
pb_findclusters <- progress_bar$new(total = length(SU_genes),
format =   "[:bar] :percent eta: :eta")
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
cl <- detectCores()-2
library(parallel)
cl <- detectCores()-2
bla <- mclapply(SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
}, mc.cores = cl)
su_i_j_matrix <- as.data.frame(bla)
rownames(su_i_j_matrix) <- su_ic_vector_small$gene
colnames(su_i_j_matrix) <- su_ic_vector_small$gene
View(su_i_j_matrix)
su_ic_vector_small$gene
su_ic_vector_small$gene[grep("HLA"),su_ic_vector_small$gene]
su_ic_vector_small$gene[grep("HLA", su_ic_vector_small$gene)]
grep("HLA", su_ic_vector_small$gene)
su_ic_vector_small$gene
su_ic_vector$gene <- gsub('\\.', '-',rownames(su_ic_vector))
# get and adjacency matrix for gene to gene correlation
su_i_j_matrix <- data.frame(genes =  SU_genes)
# this can surely be improved for speed.
for (i in SU_genes) {
#  pb_findclusters$tick()
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
}
devtools::install()
install()
fc <- mod_ora(fc)
data('gmt')
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_in <- read_gmt(gmt_fname)
fc <- mod_ora(fc, gmt_in)
install()
fc <- readRDS("~/side/fcoex/data/fc.rds")
discretized_exprs <- fc@discretized_expression
target <- fc@target
su_ic_vector <- FCBF::get_su(discretized_exprs, target)
su_ic_vector$gene <- gsub('\\.', '-',rownames(su_ic_vector))
colnames(su_ic_vector)[1] <- 'SU'
message('Running FCBF to find module headers')
fcbf_filtered <- FCBF::fcbf(discretized_exprs, target, n_genes, thresh = FCBF_threshold, verbose = verbose)
fcbf_filtered$gene <- rownames(fcbf_filtered)
# R does not like points. Subs for -.
FCBF_genes <- gsub('\\.', '-', fcbf_filtered$gene)
if (length(n_genes)){
FCBF_threshold <- su_ic_vector$SU[n_genes]
}
# get only those with an SU score above a threshold
SU_threshold <- FCBF_threshold
su_ic_vector_small <- su_ic_vector[su_ic_vector[1] > SU_threshold,]
SU_genes <- gsub('\\.', '-',su_ic_vector_small[,2])
fc@selected_genes <-SU_genes
exprs_small <- discretized_exprs[SU_genes ,]
# get and adjacency matrix for gene to gene correlation
su_i_j_matrix <- data.frame(genes =  SU_genes)
message('Calculating adjacency matrix')
pb_findclusters <- progress_bar$new(total = length(SU_genes),
format =   "[:bar] :percent eta: :eta")
library(progress)
pb_findclusters <- progress_bar$new(total = length(SU_genes),
format =   "[:bar] :percent eta: :eta")
# this can surely be improved for speed.
for (i in SU_genes) {
pb_findclusters$tick()
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
}
su_i_j_matrix <- su_i_j_matrix[,-1]
View(su_i_j_matrix)
filtered_su_i_j_matrix <- data.frame(genes =  SU_genes)
message('Getting modules from adjacency matrix')
for (i in colnames(su_i_j_matrix)){
if (all(gsub("\\.", "-",su_ic_vector$gene[seq_len(length(su_i_j_matrix$genes))]) == as.character(su_i_j_matrix$genes))){
tf_vector <- su_i_j_matrix[,i] > su_ic_vector$SU[seq_len(length(su_i_j_matrix$genes))]
filtered_su_i_j_matrix[,i] <- su_i_j_matrix[,i] * tf_vector
}
}
tf_vector <- su_i_j_matrix[,i] > su_ic_vector$SU[seq_len(length(su_i_j_matrix$genes))]
su_i_j_matrix[,i]
su_ic_vector$SU
seq_len(length(su_i_j_matrix$genes))
tf_vector <- su_i_j_matrix[,i] > su_ic_vector$SU[seq_len(length(su_ic_vector_small$gene))]
i <- FCBF_genes[2]
tf_vector <- su_i_j_matrix[,i] > su_ic_vector$SU[seq_len(length(su_ic_vector_small$gene))]
i <- FCBF_genes[1]
tf_vector <- su_i_j_matrix[,i] > su_ic_vector$SU[seq_len(length(su_ic_vector_small$gene))]
filtered_su_i_j_matrix[,i] <- su_i_j_matrix[,i] * tf_vector
INSTALL
install()
install()
fc <- mod_ora(fc, gmt_in)
fc@ora
fc@ora
#fc <- get_args(fc=fc, vars=mget(ls()))
ora_splitted <- split(fc@ora, fc@ora$Module)
module_cols <- fc@mod_colors
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module),
...)
})
#' @keywords internal
#'
#' @param es a data.frame from ora function containing only one module
#' @param ordr_by column to order the data.frame
#' @param max_length max length of a gene set name
#' @param pv_cut p-value cuttoff
#' @param graph_color color of bars
#' @param title title of the graph
#'
#' @return a list with ggplot2 object and the number of significant gene sets
plot_ora_single <- function(es, ordr_by='p.adjust', max_length=50, pv_cut=0.05,
graph_color="#4169E1", title="Over Representation Analysis"){
comsub <- function(x){
#split the first and last element by character
d_x <- strsplit(x[c(1, length(x))], "")
#search for the first not common element, and so, get the last matching one
der_com <- match(FALSE, do.call("==", d_x))-1
return(substr(x, 1, der_com + 1))
}
es[, "GeneSet"] <- es[, "ID"]
# limits name length
ovf_rows <- which(nchar(es[, "GeneSet"]) > max_length) # overflow
ovf_data <- es[ovf_rows, "GeneSet"]
test <- strtrim(ovf_data, max_length)
dupes <- duplicated(test) | duplicated(test, fromLast=TRUE)
if(sum(dupes) > 0){
test[dupes] <- ovf_data[dupes]
test[dupes] <- comsub(test[dupes])
max_length <- max(nchar(test))
}
es[ovf_rows, "GeneSet"] <-  paste0(strtrim(test, max_length), "...")
es[, "GeneSet"] <- stringr::str_wrap(es[, "GeneSet"], width = 20)
# order bars
lvls <- es[order(es[, ordr_by], decreasing=TRUE), "GeneSet"]
es[, "GeneSet"] <- factor(es[, "GeneSet"], levels=lvls)
es[, "alpha"] <- 1
es[es[, ordr_by] > pv_cut, "alpha"] <- 0
# Avoid 0's
es[es[, ordr_by] > 0.8, ordr_by] <- 0.8
my_squish <- function(...){
return(scales::squish(..., only.finite=FALSE))
}
# plot
y_axis <- paste('-log10(', ordr_by, ')')
pl <- ggplot(es, aes_string(x="GeneSet", y=y_axis, alpha="alpha", fill=y_axis)) +
geom_bar(stat="identity") +
theme(axis.text=element_text(size=8), legend.title=element_blank()) +
coord_flip() +
scale_alpha(range=c(0.4, 1), guide="none") +
labs(y="-log10(adjusted p-value)", title=title, x="") +
geom_hline(yintercept=-log10(pv_cut), colour="grey", linetype="longdash") +
scale_fill_gradient(low="gray", high=graph_color, limits=c(2, 5), oob=my_squish)
res <- list('pl'=pl, numsig=sum(es[, ordr_by] < pv_cut, na.rm=TRUE))
return(res)
}
#fc <- get_args(fc=fc, vars=mget(ls()))
ora_splitted <- split(fc@ora, fc@ora$Module)
module_cols <- fc@mod_colors
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module),
...)
})
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module))
n = 10
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module))
})
pv_cut=0.05
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module))
})
library(ggplot2)
res <- lapply(ora_splitted, function(x){
plot_ora_single(head(x, n=n),
pv_cut=pv_cut,
graph_color=module_cols[unique(x$Module)],
title=unique(x$Module))
})
modules <- names(res)
modules <- modules[names(fc@module_list)]
fc@barplot_ora <- res[modules]
save_plots(fc)
save_plots(fc, T)
save_plots(fc, force = T)
save_plots(name = "ble', fc, force = T)
save_plots(name = "ble", fc, force = T)
fc@barplot_ora <- res[modules]
save_plots(name = "ble", fc, force = T)
fc@barplot_ora[1]
res[1]
res[2]
fc@barplot_ora <- res
save_plots(name = "ble", fc, force = T)
document()
library(TENxPBMCData)
installed.packages(TENxPBMCData)
installed.packages(TENxPBMCData)
install.packages(TENxPBMCData)
install.packages('TENxPBMCData')
BiocManager::install('TENxPBMCData')
# normalize data
sce <- scater::normalize(sce)
BiocManager::install('TENxPBMCData', 'scater')
BiocManager::install(c('TENxPBMCData', 'scater'))
BiocManager::install('scran')
BiocManager::install('scran')
BiocManager::install('scran')
library(scran)
quote(rJava, boot, class, codetools, foreign, KernSmooth, lattice,
Matrix, mgcv, nlme, nnet, spatial, survival)
as.character(expression(rJava, boot, class, codetools, foreign, KernSmooth, lattice,
Matrix, mgcv, nlme, nnet, spatial, survival))
pkgs <- as.character(expression(rJava, boot, class, codetools, foreign, KernSmooth, lattice,
Matrix, mgcv, nlme, nnet, spatial, survival))
remove.packages(pkgs)
install.packages(pkgs)
install.packages(pkgs)
install.packages(pkgs)
BiocManager::install('scater')
BiocManager::install('scran')
sce <- TENxPBMCData('pbmc3k')
library(TENxPBMCData)
sce <- TENxPBMCData('pbmc3k')
sce <- TENxPBMCData('pbmc3k')
## reassign rownames
rownames(sce) <- rowData(sce)[, "Symbol_TENx"]
## counts dupes from top to bottom to make a logical vector and remove-it
dupes <- duplicated(rownames(sce))
sce <- sce[!dupes, ]
# normalize data
sce <- scater::normalize(sce)
#get variable genes and run PCA
library(scran)
fit <- trendVar(sce, use.spikes = FALSE)
fit <- trendVar(sce, use.spikes = FALSE)
dec <- decomposeVar(sce, fit)
dec <- dec[order(dec$bio, decreasing = TRUE), ] # order by bio var
hvg_genes <- rownames(dec)[dec$bio > 0]
metadata(sce)$hvg_genes <- hvg_genes
sce <- runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
sce <- scater::runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
sce <- scater::runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
# get clusters
set.seed(1234) # to make results reproducible
snng <- buildSNNGraph(sce, k = 50, d = 20)
snng_clusters <- igraph::cluster_louvain(snng)
colData(sce)$clusters <- as.factor(snng_clusters$membership)
colData(sce)$clusters
hvg_genes[1:250]
sce
exprs <- assay(sce, 'logcounts')
target <- colData(sce)$clusters
library(fcoex)
fc <- new_fcoex(exprs, target)
exprs <- as.data.frame(assay(sce, 'logcounts'))
fc <- new_fcoex(exprs, target)
fc <- discretize(fc)
fc <- new_fcoex(data.frame(exprs),target)
fc <- discretize(fc, number_of_bins = 8)
fc <- discretize(fc, number_of_bins = 8)
devtools::document()
devtools::install()
fc <- discretize(fc, number_of_bins = 8)
discretized_expression <-FCBF::discretize_exprs(expression_table = exprs,
number_of_bins = 8,
method = "varying_width",
alpha = 1,
centers = 3,
min_max_cutoff = 0.25,
show_pb = TRUE)
discretized_expression <-FCBF::discretize_exprs(expression_table = exprs,
number_of_bins = 8)
devtools::install_github('lubianat/FCBF')
#BiocManager::install(c('TENxPBMCData', 'scater', 'scran'))
library(TENxPBMCData)
sce <- TENxPBMCData('pbmc3k')
## reassign rownames
rownames(sce) <- rowData(sce)[, "Symbol_TENx"]
## counts dupes from top to bottom to make a logical vector and remove-it
dupes <- duplicated(rownames(sce))
sce <- sce[!dupes, ]
# normalize data
sce <- scater::normalize(sce)
#get variable genes and run PCA
library(scran)
fit <- trendVar(sce, use.spikes = FALSE)
dec <- decomposeVar(sce, fit)
dec <- dec[order(dec$bio, decreasing = TRUE), ] # order by bio var
hvg_genes <- rownames(dec)[dec$bio > 0]
metadata(sce)$hvg_genes <- hvg_genes
sce <- scater::runPCA(sce, ncomponents = 50,
feature_set = hvg_genes)
# get clusters
set.seed(1234) # to make results reproducible
snng <- buildSNNGraph(sce, k = 50, d = 20)
snng_clusters <- igraph::cluster_louvain(snng)
colData(sce)$clusters <- as.factor(snng_clusters$membership)
target <- colData(sce)$clusters
exprs <- as.data.frame(assay(sce, 'logcounts'))
library(fcoex)
fc <- new_fcoex(data.frame(exprs),target)
fc <- discretize(fc, number_of_bins = 8)
sce.pbmc
data(sce.pbmc)
data("sce.pbmc"")
data("sce.pbmc")
data("sce.pbmc")
snng <- buildSNNGraph(sce, k = 50, d = 20, use.dimred = "PCA")
snng <- buildSNNGraph(sce, k = 50, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
snng_clusters
snng_clusters$membership
table(snng_clusters$membership)
snng <- buildSNNGraph(sce, k = 5, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
snng <- buildSNNGraph(sce, k = 5, use.dimred = "PCA")
table(snng_clusters$membership)
snng <- buildSNNGraph(sce, k = 15, use.dimred = "PCA")
snng_clusters <- igraph::cluster_louvain(snng)
snng_clusters <- igraph::cluster_louvain(snng)
snng_clusters$membership
table(snng_clusters$membership)
