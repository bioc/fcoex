gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
su_i_j_matrix <- data.frame(genes =  SU_genes)
exprs_small <- discretized_exprs[SU_genes ,]
bla <- pblapply(SU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
FCBF::get_su
library(FCBF)
get_su
detach(name = "package:F", unload =T)
detach(name = "package:FCBF", unload =T)
get_su <- function(x, y, samples_in_rows = FALSE) {
if (!samples_in_rows){
x <- t(x)
}
if (!is.data.frame(x)){
x <- data.frame(x)
}
su_ic <- pbapply(x, 2, function(xx, yy) {
SU(xx, yy)
}, y)
su_ic <- as.data.frame(sort(su_ic,decreasing = TRUE))
su_ic$gene <- rownames(su_ic)
su_ic
}
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
su_i_j_matrix <- data.frame(genes =  SU_genes)
exprs_small <- discretized_exprs[SU_genes ,]
bla <- pblapply(SU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
# Based on implementation  from Rajarshi Guha <rajarshi@presidency.com>
# 13/05/2005
#
# Modified by Tiago Lubiana (22/08/2018)
# Functions to calculate forms of entropy for categorical variables ("factors")
# H(X) - entropy
entropy <- function(x, base = exp(1)) {
if (!is.factor(x)) {
stop("For calculating the entropy, the vector must be a factor")
}
x <- factor(x)
t <- table(x)
probabily_of_t <- t / sum(t)
if (any(t == 0)) {
probabily_of_t <- probabily_of_t[-which(t == 0)]
}
ent <- -1 * sum(probabily_of_t * log(probabily_of_t) / log(base))
if (is.na(ent)) {
ent <- 0
}
ent
}
# H(X,Y) - joint entropy
entropy.joint <- function(x, y, base = exp(1)) {
if (!is.factor(x) || !is.factor(y)) {
stop("For calculating the joint entropy, the vector x & y must be factors")
}
x <- factor(x)
y <- factor(y)
t <- table(x, y)
probabily_of_t <- as.numeric(t / sum(t))
if (any(probabily_of_t == 0)) {
probabily_of_t <- probabily_of_t[-which(probabily_of_t== 0)]
}
ent <- -1 * sum(probabily_of_t * log(probabily_of_t) / log(base))
if (is.na(ent)) {
ent <- 0
}
ent
}
# H(X|Y) = H(X,Y) - H(Y) - conditional entropy
entropy.cond <- function(x, y, base = exp(1)) {
if (!is.factor(x) || !is.factor(y)) {
stop("For calculating the conditional entropy, the vectors x & y must be factors")
}
ent <- entropy.joint(x, y, base) - entropy(y, base)
if (is.na(ent)) {
ent <- 0
}
ent
}
#'  Symmetrical Uncertainty diagnostic
# Formula for symetrical uncertainty as described in  Yu, L. and Liu, H. , 2003.
#' This functions runs symmetrical uncertainty for two features,
#' returning the score
#'
#' @param x A vector containing a categorical feature
#' @param y A vector containing other categorical feature
#' @return A numerical value for the Symetrical Uncertainty score
#' @export
#' @examples
#'  data(scDengue)
#'  exprs <- SummarizedExperiment::assay(scDengue, 'logcounts')
#'  discrete_expression <- as.data.frame(discretize_exprs(exprs))
#'  discrete_expression_gene_1 <- discrete_expression$V1
#'  discrete_expression_gene_2 <- discrete_expression$V2
#'  SU(discrete_expression_gene_1,discrete_expression_gene_2)
SU <- function(x, y, base = exp(1)) {
if (is.character(x)) {
x <- as.factor(x)
}
if (!is.factor(x) || !is.factor(y)) {
stop(
"For calculating the symmetrical uncertainty, the vectors x & y must be factors.
Using a continuous(numeric) feature set leads to this error."
)
}
Ht <- entropy.joint(x, y, base)
Hx <- entropy(x, base)
Hy <- entropy(y, base)
#cat(Ht,' ',Hx,' ',Hy,'\n')
# Returns the symmetrical uncertainty value for the vector pair
2 * (Hy + Hx - Ht) / (Hx + Hy)
}
#'  Information Gain
#' This functions runs Information Gain for two features,
#' returning the score
#'
#' @param x A vector containing a categorical feature
#' @param y A vector containing other categorical feature
#' @return A numerical value for the Information Gain score
#' @export
#' @examples
#'   data(scDengue)
#'   exprs <- SummarizedExperiment::assay(scDengue, 'logcounts')
#'   discrete_expression <- as.data.frame(discretize_exprs(exprs))
#'   discrete_expression_gene_1 <- discrete_expression$V1
#'   discrete_expression_gene_2 <- discrete_expression$V2
#'   IG(discrete_expression_gene_1,discrete_expression_gene_2)
# Formula for Information Gain
IG <- function(x, y, base = exp(1)) {
if (is.character(x)) {
x <- as.factor(x)
}
if (!is.factor(x) || !is.factor(y)) {
stop(
"For calculating the information gain, the vectors x & y must be factors.
Using a continuous(numeric) feature set leads to this error."
)
}
Ht <- entropy.joint(x, y, base)
Hx <- entropy(x, base)
Hy <- entropy(y, base)
# Returns the information gain for the pair
IG <- (Hy + Hx - Ht)
IG
}
bla <- pblapply(SU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
#'  Symmetrical Uncertainty diagnostic
#'
#' This functions runs symmetrical uncertainty for a feature table and a class, returning
#' the scores of symmetrical uncertainty for all features
#'
#' @param x A table of features (observations in rows, variables in columns)
#' @param y A target vector, factor containing classes of the observations. Note: the
#' observations must be in the same order as the parameter x.
#' @param samples_in_rows A flag for the case in which samples are in rows and variables/genes in columns. Defaults to FALSE.
#' @param bar_of_progress A flag to show progress. Defaults to FALSE.
#' @return A dataframe containing the SU values for each feature
#' @import pbapply
#' @export
#' @examples
#' data(scDengue)
#' exprs <- SummarizedExperiment::assay(scDengue, 'logcounts')
#' discrete_expression <- as.data.frame(discretize_exprs(exprs))
#' infection <- SummarizedExperiment::colData(scDengue)
#' target <- infection$infection
#' su_values <- get_su(discrete_expression[,],target[])
#' su_values[1:10,]
get_su <- function(x, y, samples_in_rows = FALSE, bar_of_progress = FALSE) {
if (!samples_in_rows){
x <- t(x)
}
if (!is.data.frame(x)){
x <- data.frame(x)
}
if (bar_of_progress){
su_ic <- pbapply(x, 2, function(xx, yy) {
SU(xx, yy)
}, y)
} else{
su_ic <- apply(x, 2, function(xx, yy) {
SU(xx, yy)
}, y)
}
su_ic <- as.data.frame(sort(su_ic,decreasing = TRUE))
su_ic$gene <- rownames(su_ic)
su_ic
}
bla <- pblapply(SU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
bla <- pblapply(SU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
ble <- as.data.frame(bla)
su_i_j_matrix <- as.data.frame(ble)
su_i_j_matrix <- as.data.frame(bla)
filtered_su_i_j_matrix <- data.frame(genes =  SU_genes)
message('Getting modules from adjacency matrix')
for (i in colnames(su_i_j_matrix[,-1])){
if (all(gsub("\\.", "-",su_ic_vector$gene[seq_len(length(su_i_j_matrix$genes))]) == as.character(su_i_j_matrix$genes))){
tf_vector <- su_i_j_matrix[,i] > su_ic_vector$SU[seq_len(length(su_i_j_matrix$genes))]
filtered_su_i_j_matrix[,i] <- su_i_j_matrix[,i] * tf_vector
}
}
list_of_fcbf_modules <- list()
for (seed in FCBF_genes){
module_members <- as.character(filtered_su_i_j_matrix$genes[filtered_su_i_j_matrix[,seed]>0])
module_members <- module_members[!is.na(module_members)]
if(length(module_members) > 1) {
list_of_fcbf_modules[[seed]] <- module_members
}
}
fcbf_filtered <- FCBF::fcbf(discretized_exprs, target, n_genes, thresh = FCBF_threshold, verbose = verbose)
filtered_su_i_j_matrix
pb_findclusters <- progress_bar$new(total = length(SU_genes),
format =   "[:bar] :percent eta: :eta")
# this can surely be improved for speed.
for (i in SU_genes) {
pb_findclusters$tick()
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
}
# this can surely be improved for speed.
for (i in SU_genes) {
pb_findclusters$tick()
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- rownames(gene_i_correlates)
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
}
pb_findclusters <- progress_bar$new(total = length(SU_genes),
format =   "[:bar] :percent eta: :eta")
# this can surely be improved for speed.
for (i in SU_genes) {
pb_findclusters$tick()
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- rownames(gene_i_correlates)
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
}
library(parallel)
cl <- makeCluster(detectCores())
cl <- makeCluster(detectCores()-2)
cl <- makeCluster(detectCores()-2)
bla <- parlapply(clSU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
library(parallel)
bla <- parLapply(clSU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
bla <- parLapply(cl,SU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
#'     gene_i <- as.factor(discretized_exprs[i, ])
#'     gene_i_correlates <- get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
#'     gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
#'     gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
#'     colnames(gene_i_correlates)[1] <- i
#'     su_i_j_matrix[, i] <- gene_i_correlates[,1]
#'     su_i_j_matrix[, i]
#'   }
#      This was not faster than the for loop! ######
#
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
#      This was not faster than the for loop! ######
#
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
bla <- parLapply(cl,SU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
#      This was not faster than the for loop! ######
#
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
bla <- parLapply(cl,SU_genes, function(x){
get_correlates(x, su_i_j_matrix, discretized_exprs, exprs_small)
})
bla <- parLapply(cl,SU_genes, function(i){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
})
bla <- parLapply(cl,SU_genes, function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
})
clusterExport(cl=cl, varlist = c("su_i_j_matrix", "discretized_exprs", "exprs_small"))
bla <- parLapply(cl,SU_genes, function(i){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
})
bla <- parLapply(cl,SU_genes, function(i){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
})
tic()
bla <- parLapply(cl,SU_genes, function(i){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
})
toc()
su_i_j_matrix <- as.data.frame(bla)
View(su_i_j_matrix)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
#      This was not faster than the for loop! ######
#
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
library(parallel)
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
bla[1:3,1:3]
su_i_j_matrix <- as.data.frame(bla)
# get and adjacency matrix for gene to gene correlation
su_i_j_matrix <- data.frame(genes =  SU_genes)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
toc()
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
toc()
su_i_j_matrix <- as.data.frame(bla)
rownames(su_i_j_matrix)
rownames(su_i_j_matrix) <- su_ic_vector_small$gene
colnames(su_i_j_matrix) <- su_ic_vector_small$gene
filtered_su_i_j_matrix <- data.frame(genes =  SU_genes)
message('Getting modules from adjacency matrix')
for (i in colnames(su_i_j_matrix[,-1])){
if (all(gsub("\\.", "-",su_ic_vector$gene[seq_len(length(su_i_j_matrix$genes))]) == as.character(su_i_j_matrix$genes))){
tf_vector <- su_i_j_matrix[,i] > su_ic_vector$SU[seq_len(length(su_i_j_matrix$genes))]
filtered_su_i_j_matrix[,i] <- su_i_j_matrix[,i] * tf_vector
}
}
list_of_fcbf_modules <- list()
n_genes = 50
verbose = T
fcbf_filtered <- FCBF::fcbf(discretized_exprs, target, n_genes, thresh = FCBF_threshold, verbose = verbose)
fcbf_filtered$gene <- rownames(fcbf_filtered)
# R does not like points. Subs for -.
FCBF_genes <- gsub('\\.', '-', fcbf_filtered$gene)
if (length(n_genes)){
FCBF_threshold <- su_ic_vector$SU[n_genes]
}
# get only those with an SU score above a threshold
SU_threshold <- FCBF_threshold
su_ic_vector_small <- su_ic_vector[su_ic_vector[1] > SU_threshold,]
SU_genes <- gsub('\\.', '-',su_ic_vector_small[,2])
fc@selected_genes <-SU_genes
exprs_small <- discretized_exprs[SU_genes ,]
# get and adjacency matrix for gene to gene correlation
su_i_j_matrix <- data.frame(genes =  SU_genes)
message('Calculating adjacency matrix')
pb_findclusters <- progress_bar$new(total = length(SU_genes),
format =   "[:bar] :percent eta: :eta")
# this can surely be improved for speed.
for (i in SU_genes) {
pb_findclusters$tick()
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
}
# Second Try
get_correlates <- function(i, su_i_j_matrix, discretized_exprs, exprs_small){
gene_i <- as.factor(discretized_exprs[i, ])
gene_i_correlates <- FCBF::get_su(x = exprs_small, y = as.factor(exprs_small[i, ]))
gene_i_correlates$gene <- gsub('\\.', '-',rownames(gene_i_correlates))
gene_i_correlates <- gene_i_correlates[match(su_i_j_matrix$genes,gene_i_correlates$gene),]
colnames(gene_i_correlates)[1] <- i
su_i_j_matrix[, i] <- gene_i_correlates[,1]
su_i_j_matrix[, i]
}
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
toc()
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
toc()
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
stopCluster(cl)
cl <- makeCluster(detectCores()-2)
clusterExport(cl=cl, varlist = c("get_correlates","su_i_j_matrix", "discretized_exprs", "exprs_small"))
tic()
bla <- parLapply(cl,SU_genes, function(i){
get_correlates(i, su_i_j_matrix, discretized_exprs, exprs_small)
})
toc()
stopCluster(cl)
stopCluster(cl)
stopCluster(cl)
stopCluster(cl)
str(discretized_exprs)
#' @param n_genes Sets the number of genes to be selected in the first part of the algorithm.
#' If left unchanged, it defaults to NULL and the thresh parameter is used.
#' Caution: it overrides the thresh parameter altogether.
#' @return Returns a list with the CBF modules found or a adjacency matrix of the graph
#' @import dplyr
#' @import parallel
#' @import progress
#' @import FCBF
#' @exportSSS
#' @rdname find_cbf_modules
setGeneric("find_cbf_modules", function(fc, ...) {
standardGeneric("find_cbf_modules")
})
source('~/Documents/Projects/side/fcoex/R/fcoex.R', echo=TRUE)
