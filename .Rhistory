#' show_plot(fc, "beta_r2")
#' @rdname show_plot
#' @export
setGeneric('show_plot', function(fc, value) {
standardGeneric('show_plot')
})
#' @rdname show_plot
setMethod('show_plot', signature('fcoex'),
function(fc, value=c("profile", "gsea", "ora", "interaction",
"beta_r2", "mean_k", "sample_tree", "mean_var",
"hist", "qq")) {
value <- match.arg(value)
if(value!="sample_tree"){
x_plot <- switch(value,
profile=fc@profile_plot,
gsea=fc@enrichment_plot,
ora=fc@barplot_ora,
interaction=fc@interaction_plot,
beta_r2=fc@beta_r2_plot,
mean_k=fc@mean_k_plot,
mean_var=fc@mean_var_plot,
hist=fc@hist_plot,
qq=fc@qq_plot)
return(x_plot)
}else{
grid::grid.draw(fc@sample_tree_plot)
}
})
#' @title
#' Save fcoex object plots
#'
#' @description
#' Save plots into the directory specified by the \code{directory} argument.
#'
#' @param fc Object of class \code{fcoex}.
#' @param value A character string containing the name of the plot to be saved.
#' @param directory Directory into which the files will be saved.
#' @param force If the directory exists, execution will not stop.
#' @param ... Optional parameters
#' One of "all", "profile", "gsea", "ora", "interaction", "beta_r2", "mean_k",
#' "sample_tree", "mean_var", "hist", "qq".
#'
#' @return A pdf file or files with the desired plot(s)
#'
#' @examples
#' # Get example fcoex object
#' data(fc)
#' # Plot beta x R squared graph
#' fc <- plot_beta_r2(fc)
#' # Save plot
#' \dontrun{save_plots(fc, value="beta_r2", directory="./Plots")}
#' @rdname save_plots
#' @export
setGeneric('save_plots', function(fc, ...) {
standardGeneric('save_plots')
})
#' @rdname save_plots
setMethod('save_plots', signature('fcoex'),
function(fc, value=c("all", "profile", "gsea", "ora",
"interaction", "beta_r2", "mean_k",
"sample_tree", "mean_var", "hist", "qq"),
force=FALSE, directory="./Plots") {
if(dir.exists(directory)){
if(!force){
stop("Stopping analysis: ", directory, " already exists! Use force=TRUE to overwrite.")
}
}else{
dir.create(directory, recursive=TRUE)
}
value <- match.arg(value)
if(value == "all"){
plots <- list(fc@profile_plot, fc@enrichment_plot, fc@barplot_ora,
fc@interaction_plot, fc@beta_r2_plot, fc@mean_k_plot,
fc@sample_tree_plot, fc@mean_var_plot, fc@hist_plot,
fc@qq_plot)
all_plots<- c("profile", "gsea", "ora", "interaction", "beta_r2", "mean_k",
"sample_tree", "mean_var", "hist", "qq")
names(plots) <- all_plots
plots <- Filter(function(x) length(x) >= 1, plots)
if(length(plots) < length(all_plots)){
message("Some plots have not been defined. Please run the appropriate plot functions. Saving available plots.")
}
lapply(names(plots), function(pl){
pdf(file=file.path(directory, paste0(pl, ".pdf")))
if(pl=="sample_tree"){
if(!is.null(nrow(plots[[pl]]))){
grid::grid.draw(plots[[pl]])
dev.off()
}
}else{
print(plots[[pl]])
dev.off()
}
})
}else if(value=="sample_tree"){
if(!is.null(nrow(fc@sample_tree_plot))){
pdf(file.path(directory, paste0(value, ".pdf")))
grid::grid.draw(fc@sample_tree_plot)
dev.off()
}else{
stop("Plot not available! Please use the appropriate plotting function on the fcoex object.")
}
}else{
x_plot <- switch(value,
profile=fc@profile_plot,
gsea=fc@enrichment_plot,
ora=fc@barplot_ora,
interaction=fc@interaction_plot,
beta_r2=fc@beta_r2_plot,
mean_k=fc@mean_k_plot,
mean_var=fc@mean_var_plot,
hist=fc@hist_plot,
qq=fc@qq_plot)
pdf(file.path(directory, paste0(value, ".pdf")))
print(x_plot)
dev.off()
}
})
pl <- ggplot(plotcord)
# get coordinates from Fruchterman and Reingold's force-directed placement algorithm.
plotcord <-
data.frame(sna::gplot.layout.fruchtermanreingold(m, NULL))
m <-      network::as.matrix.network.adjacency(net_obj) # get sociomatrix
net_obj <- intergraph::asNetwork(ig_obj)
adj <- as.matrix(adjacency_matrix)
ig_obj <- graph.adjacency(adj, weighted = T)
degrees <- igraph::degree(ig_obj, normalized = FALSE)
ig_obj <-
igraph::set_vertex_attr(ig_obj, "degree", value = degrees)
net_obj <- intergraph::asNetwork(ig_obj)
m <-      network::as.matrix.network.adjacency(net_obj) # get sociomatrix
# get coordinates from Fruchterman and Reingold's force-directed placement algorithm.
plotcord <-
data.frame(sna::gplot.layout.fruchtermanreingold(m, NULL))
# or get it them from Kamada-Kawai's algorithm:
# plotcord <- data.frame(sna::gplot.layout.kamadakawai(m, NULL))
colnames(plotcord) <- c("X1", "X2")
edglist <- network::as.matrix.network.edgelist(net_obj)
edges <-
data.frame(plotcord[edglist[, 1], ], plotcord[edglist[, 2], ])
plotcord$vertex.names <-
as.factor(network::get.vertex.attribute(net_obj, "vertex.names"))
plotcord$Degree <-
network::get.vertex.attribute(net_obj, "degree")
plotcord[, "shouldLabel"] <- FALSE
max_n <- min(n, length(degrees))
int_hubs <- names(sort(degrees, decreasing = TRUE))[1:max_n]
int_bool <- plotcord[, "vertex.names"] %in% int_hubs
sel_vertex <- int_hubs
colnames(edges) <-  c("X1", "Y1", "X2", "Y2")
#edges$midX  <- (edges$X1 + edges$X2) / 2
#edges$midY  <- (edges$Y1 + edges$Y2) / 2
plotcord[which(plotcord[, "vertex.names"] %in% sel_vertex), "shouldLabel"] <-
TRUE
plotcord$Degree_cut <-
cut(plotcord$Degree,
breaks = 3,
labels = FALSE)
plotcord$in_mod <- TRUE
pl <- ggplot(plotcord)  +
geom_segment(data=edges, aes_(x=~X1, y=~Y1, xend=~X2, yend=~Y2),
size = 0.5, alpha=0.5, colour="#DDDDDD") +
geom_point(aes_(x=~X1, y=~X2, size=~Degree, alpha=~Degree), color=color) +
geom_label_repel(
aes_( x =  ~ X1,   y =  ~ X2,  label =  ~ vertex.names        ),
box.padding=unit(1, "lines"),
data=function(x){x[x$shouldLabel, ]}) +
+
scale_colour_manual(values = c("#005E87")) +
labs(title = name) +
ggplot2::theme_bw(base_size = 12, base_family = "") +
ggplot2::theme(
axis.text = ggplot2::element_blank(),
axis.ticks = ggplot2::element_blank(),
axis.title = ggplot2::element_blank(),
legend.key = ggplot2::element_blank(),
panel.background = ggplot2::element_rect(fill = "white",
colour = NA),
panel.border = ggplot2::element_blank(),
panel.grid = ggplot2::element_blank())
plot_interaction <- function(adjacency_matrix, n, color, name){
adj <- as.matrix(adjacency_matrix)
ig_obj <- graph.adjacency(adj, weighted = T)
degrees <- igraph::degree(ig_obj, normalized = FALSE)
ig_obj <-
igraph::set_vertex_attr(ig_obj, "degree", value = degrees)
net_obj <- intergraph::asNetwork(ig_obj)
m <-      network::as.matrix.network.adjacency(net_obj) # get sociomatrix
# get coordinates from Fruchterman and Reingold's force-directed placement algorithm.
plotcord <-
data.frame(sna::gplot.layout.fruchtermanreingold(m, NULL))
# or get it them from Kamada-Kawai's algorithm:
# plotcord <- data.frame(sna::gplot.layout.kamadakawai(m, NULL))
colnames(plotcord) <- c("X1", "X2")
edglist <- network::as.matrix.network.edgelist(net_obj)
edges <-
data.frame(plotcord[edglist[, 1], ], plotcord[edglist[, 2], ])
plotcord$vertex.names <-
as.factor(network::get.vertex.attribute(net_obj, "vertex.names"))
plotcord$Degree <-
network::get.vertex.attribute(net_obj, "degree")
plotcord[, "shouldLabel"] <- FALSE
max_n <- min(n, length(degrees))
int_hubs <- names(sort(degrees, decreasing = TRUE))[1:max_n]
int_bool <- plotcord[, "vertex.names"] %in% int_hubs
sel_vertex <- int_hubs
colnames(edges) <-  c("X1", "Y1", "X2", "Y2")
#edges$midX  <- (edges$X1 + edges$X2) / 2
#edges$midY  <- (edges$Y1 + edges$Y2) / 2
plotcord[which(plotcord[, "vertex.names"] %in% sel_vertex), "shouldLabel"] <-
TRUE
plotcord$Degree_cut <-
cut(plotcord$Degree,
breaks = 3,
labels = FALSE)
plotcord$in_mod <- TRUE
pl <- ggplot(plotcord)  +
geom_segment(data=edges, aes_(x=~X1, y=~Y1, xend=~X2, yend=~Y2),
size = 0.5, alpha=0.5, colour="#DDDDDD") +
geom_point(aes_(x=~X1, y=~X2, size=~Degree, alpha=~Degree), color=color) +
geom_label_repel(
aes_( x =  ~ X1,   y =  ~ X2,  label =  ~ vertex.names        ),
box.padding=unit(1, "lines"),
data=function(x){x[x$shouldLabel, ]}) +
+
scale_colour_manual(values = c("#005E87")) +
labs(title = name) +
ggplot2::theme_bw(base_size = 12, base_family = "") +
ggplot2::theme(
axis.text = ggplot2::element_blank(),
axis.ticks = ggplot2::element_blank(),
axis.title = ggplot2::element_blank(),
legend.key = ggplot2::element_blank(),
panel.background = ggplot2::element_rect(fill = "white",
colour = NA),
panel.border = ggplot2::element_blank(),
panel.grid = ggplot2::element_blank())
return(pl)
}
res <- lapply(mod_names, function(name){
members_of_module <- as.character(adjacency_full$genes[adjacency_full[,name]>0])
adj <- adj[members_of_module,members_of_module]
adj <- as.matrix(adj)
plot_interaction(adj,
n=n, color=mod_cols[name], name=name)
})
n = 10
res <- lapply(mod_names, function(name){
members_of_module <- as.character(adjacency_full$genes[adjacency_full[,name]>0])
adj <- adj[members_of_module,members_of_module]
adj <- as.matrix(adj)
plot_interaction(adj,
n=n, color=mod_cols[name], name=name)
})
plot_interaction <- function(adjacency_matrix, n, color, name){
adj <- as.matrix(adjacency_matrix)
ig_obj <- graph.adjacency(adj, weighted = T)
degrees <- igraph::degree(ig_obj, normalized = FALSE)
ig_obj <-
igraph::set_vertex_attr(ig_obj, "degree", value = degrees)
net_obj <- intergraph::asNetwork(ig_obj)
m <-      network::as.matrix.network.adjacency(net_obj) # get sociomatrix
# get coordinates from Fruchterman and Reingold's force-directed placement algorithm.
plotcord <-
data.frame(sna::gplot.layout.fruchtermanreingold(m, NULL))
# or get it them from Kamada-Kawai's algorithm:
# plotcord <- data.frame(sna::gplot.layout.kamadakawai(m, NULL))
colnames(plotcord) <- c("X1", "X2")
edglist <- network::as.matrix.network.edgelist(net_obj)
edges <-
data.frame(plotcord[edglist[, 1], ], plotcord[edglist[, 2], ])
plotcord$vertex.names <-
as.factor(network::get.vertex.attribute(net_obj, "vertex.names"))
plotcord$Degree <-
network::get.vertex.attribute(net_obj, "degree")
plotcord[, "shouldLabel"] <- FALSE
max_n <- min(n, length(degrees))
int_hubs <- names(sort(degrees, decreasing = TRUE))[1:max_n]
int_bool <- plotcord[, "vertex.names"] %in% int_hubs
sel_vertex <- int_hubs
colnames(edges) <-  c("X1", "Y1", "X2", "Y2")
#edges$midX  <- (edges$X1 + edges$X2) / 2
#edges$midY  <- (edges$Y1 + edges$Y2) / 2
plotcord[which(plotcord[, "vertex.names"] %in% sel_vertex), "shouldLabel"] <-
TRUE
plotcord$Degree_cut <-
cut(plotcord$Degree,
breaks = 3,
labels = FALSE)
plotcord$in_mod <- TRUE
pl <- ggplot(plotcord)  +
geom_segment(data=edges, aes_(x=~X1, y=~Y1, xend=~X2, yend=~Y2),
size = 0.5, alpha=0.5, colour="#DDDDDD") +
geom_point(aes_(x=~X1, y=~X2, size=~Degree, alpha=~Degree), color=color) +
geom_label_repel(
aes_( x =  ~ X1,   y =  ~ X2,  label =  ~ vertex.names        ),
box.padding=unit(1, "lines"),
data=function(x){x[x$shouldLabel, ]}) +
scale_colour_manual(values = c("#005E87")) +
labs(title = name) +
ggplot2::theme_bw(base_size = 12, base_family = "") +
ggplot2::theme(
axis.text = ggplot2::element_blank(),
axis.ticks = ggplot2::element_blank(),
axis.title = ggplot2::element_blank(),
legend.key = ggplot2::element_blank(),
panel.background = ggplot2::element_rect(fill = "white",
colour = NA),
panel.border = ggplot2::element_blank(),
panel.grid = ggplot2::element_blank())
return(pl)
}
res <- lapply(mod_names, function(name){
members_of_module <- as.character(adjacency_full$genes[adjacency_full[,name]>0])
adj <- adj[members_of_module,members_of_module]
adj <- as.matrix(adj)
plot_interaction(adj,
n=n, color=mod_cols[name], name=name)
})
names(res) <- mod_names
mod_names_ordered <- mod_names[order(as.numeric(stringr::str_extract(mod_names, "\\d+")))]
names(res) <- mod_names
fc@interaction_plot <- res[mod_names]
return(fc)
#' int_df <- read.delim(int)
#' # Include interaction data into fcoex object
#' interactions_data(fc) <- int_df
#' # Plot resulting networks
#' fc <- plot_interactions(fc)
#' # Check resulting plot
#' show_plot(fc, "interaction")
#'
#' @rdname plot_interactions
#' @export
setGeneric('plot_interactions', function(fc, ...) {
standardGeneric('plot_interactions')
})
#' @rdname plot_interactions
setMethod('plot_interactions', signature('fcoex'),
function(fc, n=10, ...) {
if(length(fc@module_list) == 0){
stop("No modules in fcoex object! Did you run find_cbf_modules()?")
}
#fc <- get_args(fc, vars=mget(ls()))
mod_cols <- fc@mod_colors
mod_names <- names(fc@module_list)
adjacency_full <- fc@adjacency
adj <- fc@adjacency[,-1]
rownames(adj) <- colnames(adj)
res <- lapply(mod_names, function(name){
members_of_module <- as.character(adjacency_full$genes[adjacency_full[,name]>0])
adj <- adj[members_of_module,members_of_module]
adj <- as.matrix(adj)
plot_interaction(adj,
n=n, color=mod_cols[name], name=name)
})
names(res) <- mod_names
fc@interaction_plot <- res[mod_names]
return(fc)
})
fc <- plot_interactions(fc)
setGeneric('show_plot', function(fc, value) {
standardGeneric('show_plot')
})
#' @rdname show_plot
setMethod('show_plot', signature('fcoex'),
function(fc
) {
return(fc@interaction_plot)
#       }
})
show_plot(fc)
#'
#' @description
#' Save plots into the directory specified by the \code{directory} argument.
#'
#' @param fc Object of class \code{fcoex}.
#' @param directory Directory into which the files will be saved.
#' @param force If the directory exists, execution will not stop.
#' @return A pdf file or files with the desired plot(s)
#' @rdname save_plots
#' @export
setGeneric('save_plots', function(fc, ...) {
standardGeneric('save_plots')
})
#' @rdname save_plots
function(fc, force=FALSE, directory="./Plots") {
if(!force){
stop("Stopping analysis: ", directory, " already exists! Use force=TRUE to overwrite.")
}
#'
#' @description
#' Save plots into the directory specified by the \code{directory} argument.
#'
#' @param fc Object of class \code{fcoex}.
#' @param directory Directory into which the files will be saved.
#' @param force If the directory exists, execution will not stop.
#' @return A pdf file or files with the desired plot(s)
#' @rdname save_plots
#' @export
setGeneric('save_plots', function(fc, ...) {
standardGeneric('save_plots')
})
#' @rdname save_plots
#' @rdname save_plots
setMethod('save_plots', signature('fcoex'),
if(dir.exists(directory)){
if(!force){
stop("Stopping analysis: ", directory, " already exists! Use force=TRUE to overwrite.")
}
}else{
dir.create(directory, recursive=TRUE)
}
if(dir.exists(directory)){
if(!force){
stop("Stopping analysis: ", directory, " already exists! Use force=TRUE to overwrite.")
}
}else{
dir.create(directory, recursive=TRUE)
}
if(dir.exists(directory)){
if(!force){
stop("Stopping analysis: ", directory, " already exists! Use force=TRUE to overwrite.")
}
}else{
dir.create(directory, recursive=TRUE)
}
directory = './Plots'
if(dir.exists(directory)){
if(!force){
stop("Stopping analysis: ", directory, " already exists! Use force=TRUE to overwrite.")
}
}else{
dir.create(directory, recursive=TRUE)
}
plots <- list(fc@interaction_plot)
all_plots<- c("interaction")
names(plots) <- all_plots
if(length(plots) == 0){
message("The plots have not been defined. Please run the appropriate plot functions.")
}
lapply(names(plots), function(pl){
pdf(file=file.path(directory, paste0(pl, ".pdf")))
print(plots[[pl]])
dev.off()
}
})
names(plots)
lapply(names(plots), function(pl){
pdf(file=file.path(directory, paste0(pl, ".pdf")))
print(plots[[pl]])
dev.off()
}
})
#' @rdname save_plots
setMethod('save_plots', signature('fcoex'),
function(fc, force=FALSE, directory="./Plots") {
if(dir.exists(directory)){
if(!force){
stop("Stopping analysis: ", directory, " already exists! Use force=TRUE to overwrite.")
}
}else{
dir.create(directory, recursive=TRUE)
}
plots <- list(fc@interaction_plot)
all_plots<- c("interaction")
names(plots) <- all_plots
if(length(plots) == 0){
message("The plots have not been defined. Please run the appropriate plot functions.")
}
lapply(names(plots), function(pl){
pdf(file=file.path(directory, paste0(pl, ".pdf")))
print(plots[[pl]])
dev.off()
})
})
save_plots(fc)
save_plots(fc, force = T)
res <- lapply(mod_names, function(name){
if(length(members_of_module) >= min_elements){
members_of_module <- as.character(adjacency_full$genes[adjacency_full[,name]>0])
adj <- adj[members_of_module,members_of_module]
adj <- as.matrix(adj)
plot_interaction(adj,
n=n, color=mod_cols[name], name=name)
}
})
min_elements = 5
res <- lapply(mod_names, function(name){
if(length(members_of_module) >= min_elements){
members_of_module <- as.character(adjacency_full$genes[adjacency_full[,name]>0])
adj <- adj[members_of_module,members_of_module]
adj <- as.matrix(adj)
plot_interaction(adj,
n=n, color=mod_cols[name], name=name)
}
})
names(res) <- mod_names
fc@interaction_plot <- res[mod_names]
devtools::document()
traceback()
traceback()
devtools::document()
devtools::document()
devtools::install()
devtools::install()
library(fcoex)
expression_table <- fc@expression
devtools::document()
devtools::install()
devtools::document()
devtools::install()
